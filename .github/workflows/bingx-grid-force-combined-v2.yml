name: BingX Grid — Force Combined (v2)

on:
  workflow_dispatch:

concurrency:
  group: bingx-grid-force-combined
  cancel-in-progress: true

env:
  PY_VERSION: "3.11"
  MIN_RANGE: "1.0"
  MAX_DRIFT: "0.40"
  MAX_CV:   "0.60"
  MIN_SCORE: "25"
  FB_MIN_SCORE: "40"
  FB_MAX_CV:    "0.60"
  FB_MAX_DRIFT: "0.40"

jobs:
  patch_and_run:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        tf: ["5m","15m","1h"]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PY_VERSION }}

      - name: Install deps
        run: |
          python -m pip install -U pip wheel
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          chmod +x run_scan_broad.sh || true

      - name: Write helper scripts
        run: |
          cat > patch_bot.py <<'PY'
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import re, sys, json, os
from pathlib import Path

TARGET = Path("auto_grid_box_finder_pro.py")
if not TARGET.exists():
    print("!! auto_grid_box_finder_pro.py not found", flush=True)
    sys.exit(0)

src = TARGET.read_text(encoding="utf-8", errors="ignore")
orig = src

changes = {}

# 1) Title tag: ONLY S-GRID -> S+NEAR or fallback
src, n1 = re.subn(r'title_tag\s*=\s*"ONLY S-GRID"', 'title_tag="S+NEAR or fallback"', src)
changes["title_tag"] = n1

# 2) Header label: OKX (USDT swap) -> BingX (USDT perp)
src, n2 = re.subn(r'OKX\s*\(USDT\s*swap\)', 'BingX (USDT perp)', src)
changes["header_label"] = n2

# 3) Picks logic: prefer sgrid+near when available
patterns = [
    r'picks\s*=\s*sgrid\[:TOPK\]',
    r'picks\s*=\s*\(\s*sgrid\s*\)\s*\[:TOPK\]',
]
repl = "picks=(sgrid+near)[:TOPK] if (sgrid or near) else sorted(rows, key=lambda x: x['score'], reverse=True)[:TOPK]"
n3_total = 0
for pat in patterns:
    src, n3 = re.subn(pat, repl, src)
    n3_total += n3
changes["picks"] = n3_total

# 4) In case code prints fixed '5m' in header, try to replace with formatted TF if exists
# This is heuristic and safe to ignore if not found.
src, n4 = re.subn(r'—\s*\d+m\s*\|', '— {tf} |', src)  # harmless if not matched
changes["tf_header_hint"] = n4

if src != orig:
    TARGET.write_text(src, encoding="utf-8")
    print(">> Patch summary:", json.dumps(changes), flush=True)
else:
    print(">> No patch applied (patterns not found). Summary:", json.dumps(changes), flush=True)

PY
          cat > scan_capture.py <<'PY'
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import sys, os, runpy
from urllib.parse import urlparse, parse_qs
import requests as _req

_real_post = _req.post
_real_get  = _req.get

def _extract_text_from_kwargs(kwargs):
    js = kwargs.get("json")
    if isinstance(js, dict) and isinstance(js.get("text"), str):
        return js["text"]
    data = kwargs.get("data")
    if isinstance(data, dict) and isinstance(data.get("text"), str):
        return data["text"]
    return None

def _mirror_if_telegram(url, *args, **kwargs):
    try:
        p = urlparse(url)
        if p.netloc == "api.telegram.org" and p.path.endswith("/sendMessage"):
            text = _extract_text_from_kwargs(kwargs)
            if not text and p.query:
                q = parse_qs(p.query)
                v = q.get("text", [])
                if v and isinstance(v[0], str):
                    text = v[0]
            if text:
                print(text, flush=True)
                class _R:
                    status_code = 200
                    def json(self): return {"ok": True, "result": {"message_id": 0}}
                    def raise_for_status(self): return None
                    @property
                    def text(self): return "OK"
                return _R()
    except Exception:
        pass
    return None

def _post(url, *args, **kwargs):
    r = _mirror_if_telegram(url, *args, **kwargs)
    return r if r is not None else _real_post(url, *args, **kwargs)

def _get(url, *args, **kwargs):
    r = _mirror_if_telegram(url, *args, **kwargs)
    return r if r is not None else _real_get(url, *args, **kwargs)

def main():
    import requests
    requests.post = _post  # type: ignore
    requests.get  = _get   # type: ignore
    os.environ.setdefault("BOT_TOKEN", "0")
    os.environ.setdefault("CHAT_ID", "0")
    sys.argv = ["auto_grid_box_finder_pro.py"] + sys.argv[1:]
    runpy.run_path("auto_grid_box_finder_pro.py", run_name="__main__")

if __name__ == "__main__":
    main()

PY
          cat > grid_filter.py <<'PY'
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import re, sys, argparse
from pathlib import Path

DASH = r"(?:—|-)"
ELLIPSIS = r"(?:…|\.{3})"
RE = re.compile(
    rf"^{DASH}\s+(?P<sym>[A-Z0-9/:\-]+)\s+\|(?P<rest>.*?grid\s*\[\s*(?P<low>[0-9.eE+-]+)\s*{ELLIPSIS}\s*(?P<high>[0-9.eE+-]+)\s*\]\s*mid\s*(?P<mid>[0-9.eE+-]+)\s*\|\s*score\s*(?P<score>[0-9]+(?:\.[0-9]+)?)\s*)$"
)
def pick_float(pat, s, default=None):
    m = re.search(pat, s)
    return float(m.group(1)) if m else default

def parse_line(line):
    m = RE.search(line.strip())
    if not m: return None
    d = m.groupdict(); rest = d["rest"]
    lrng  = pick_float(r"Lrng\s+([0-9.]+)%", rest) or 0.0
    cv    = pick_float(r"\bcv\s+([0-9.]+)\b", rest) or 999.0
    drift = pick_float(r"\bd\s+([0-9.]+)%", rest) or 999.0
    altR  = pick_float(r"\baltR\s+([0-9.]+)\b", rest) or 0.0
    return {
        "raw": line.rstrip(),
        "sym": d["sym"],
        "low": float(d["low"]), "high": float(d["high"]), "mid": float(d["mid"]),
        "score": float(d["score"]), "lrng": lrng, "cv": cv, "drift": drift, "altR": altR,
    }

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("file")
    ap.add_argument("--tf", choices=["3m","5m","15m","1h"], default="5m")
    ap.add_argument("--min-range", type=float, default=1.0)
    ap.add_argument("--max-drift", type=float, default=0.40)
    ap.add_argument("--max-cv", type=float, default=0.60)
    ap.add_argument("--min-score", type=float, default=25.0)
    ap.add_argument("--fb-min-score", type=float, default=40.0)
    ap.add_argument("--fb-max-cv", type=float, default=0.60)
    ap.add_argument("--fb-max-drift", type=float, default=0.40)
    ap.add_argument("--top", type=int, default=24)
    ap.add_argument("--print-okx", action="store_true")
    args = ap.parse_args()

    p = Path(args.file)
    if not p.exists():
        print(f"⚠️ Input file not found: {p}"); sys.exit(0)
    items = []
    for ln in p.read_text(encoding="utf-8", errors="ignore").splitlines():
        ln = ln.strip()
        if not ln: continue
        it = parse_line(ln)
        if it: items.append(it)
    if not items:
        print("⚠️ No parsable candidates found."); sys.exit(0)

    kept = []
    for it in items:
        is_fb = (it["altR"] > 0.0)
        if is_fb:
            ok = (it["lrng"] >= args.min_range and it["cv"] <= args.fb_max_cv and it["drift"] <= args.fb_max_drift and it["score"] >= args.fb_min_score)
        else:
            ok = (it["lrng"] >= args.min_range and it["cv"] <= args.max_cv and it["drift"] <= args.max_drift and it["score"] >= args.min_score)
        if ok: kept.append(it)
    kept.sort(key=lambda x: x["score"], reverse=True)
    kept = kept[:args.top]
    if not kept:
        print("(no S-GRID matches)"); sys.exit(0)
    for it in kept:
        print(it["raw"])
if __name__ == "__main__":
    main()

PY
          cat > telegram_notify.py <<'PY'
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import os, sys, json, urllib.request
def send_message(token, chat_id, text):
    data = json.dumps({"chat_id": chat_id, "text": text}).encode("utf-8")
    url = f"https://api.telegram.org/bot{token}/sendMessage"
    req = urllib.request.Request(url, data=data, headers={"Content-Type":"application/json"})
    with urllib.request.urlopen(req, timeout=20) as resp:
        resp.read()
def first_lines(path, n=8):
    try:
        txt = open(path, "r", encoding="utf-8", errors="ignore").read().strip()
    except Exception:
        return []
    lines = [ln for ln in txt.splitlines() if ln.strip() and not ln.strip().startswith("(") and "No parsable" not in ln]
    return lines[:n]
if __name__ == "__main__":
    token, chat_id = os.environ.get("BOT_TOKEN",""), os.environ.get("CHAT_ID","")
    if not token or not chat_id: sys.exit(0)
    args = sys.argv[1:]
    if len(args) < 2 or len(args) % 2 != 0: sys.exit(0)
    parts = []
    for i in range(0, len(args), 2):
        path, tf = args[i], args[i+1]
        lines = first_lines(path, 8)
        if lines: parts.append(f"⏱ {tf}\n" + "\n".join(lines))
    if not parts: sys.exit(0)
    text = "🧰 Grid Candidates — BingX\n" + "\n\n".join(parts)
    send_message(token, chat_id, text)
    print("Telegram sent.")

PY
          cat > run_scan_broad.sh <<'SH'
#!/usr/bin/env bash
set -euo pipefail
TF="${1:-15m}"
OUT="scan_${TF}.txt"
: > "$OUT"

run_cmd() {
  local extra="$1"
  python scan_capture.py --timeframe "$TF" $extra 2>&1 | tee -a "$OUT"
}

echo ">>> Broad scan TF=$TF" | tee -a "$OUT"
run_cmd "--regime 96h --activation 3h --pattern s_near --fallback 1" || true
echo ">>> Done." | tee -a "$OUT"

SH
          chmod +x run_scan_broad.sh

      - name: Apply runtime patch
        run: |
          python patch_bot.py
          echo ">>> patched head:"
          sed -n '1,120p' auto_grid_box_finder_pro.py || true

      - name: Run scan (capture Telegram -> STDOUT) — ${{ matrix.tf }}
        env:
          BOT_TOKEN: "0"
          CHAT_ID:  "0"
        run: ./run_scan_broad.sh ${{ matrix.tf }}

      - name: Filter — ${{ matrix.tf }}
        run: |
          TF="${{ matrix.tf }}"
          FTF="$TF"; if [ "$TF" = "5m" ]; then FTF="3m"; fi
          echo "Using filter timeframe: $FTF (from TF=$TF)"
          python grid_filter.py scan_${TF}.txt \
            --tf "$FTF" \
            --min-range $MIN_RANGE \
            --max-drift $MAX_DRIFT \
            --max-cv $MAX_CV \
            --min-score $MIN_SCORE \
            --fb-min-score $FB_MIN_SCORE \
            --fb-max-cv $FB_MAX_CV \
            --fb-max-drift $FB_MAX_DRIFT \
            --top 24 \
            --print-okx | tee filtered_${TF}.txt

      - name: Telegram (single message per TF if any) — ${{ matrix.tf }}
        if: always()
        env:
          BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
          CHAT_ID:  ${{ secrets.CHAT_ID }}
        run: |
          python telegram_notify.py filtered_${{ matrix.tf }}.txt ${{ matrix.tf }}

      - name: Upload artifacts — ${{ matrix.tf }}
        uses: actions/upload-artifact@v4
        with:
          name: bingx-force-combined-v2-${{ matrix.tf }}-${{ github.run_id }}
          path: |
            scan_${{ matrix.tf }}.txt
            filtered_${{ matrix.tf }}.txt
